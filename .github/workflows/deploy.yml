name: Deploy to VPS

on:
  push:
    branches: [ master, main ]
  workflow_dispatch:

env:
  DOCKER_IMAGE: juscash-api
  DOCKER_TAG: ${{ github.sha }}

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run tests
      run: |
        python -m pytest tests/ -v --tb=short || true

  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    needs: test
    timeout-minutes: 30
    if: github.event_name == 'push'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy na VPS
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT }}
        script_stop: true
        timeout: 30m
        script: |
          LOG_DIR="/var/www/juscash/logs"
          mkdir -p "$LOG_DIR"
          LOG_FILE="$LOG_DIR/deploy_$(date +%Y%m%d_%H%M%S).log"
          
          log() {
              echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
          }
          
          # Desabilita sa√≠da imediata em caso de erro para permitir tentativas
          set +e
          set +o pipefail
          
          error_exit() {
              log "‚ùå ERRO na etapa: $1"
              log "Logs de debug salvos em: $LOG_FILE"
              exit 1
          }
          
          log "=== INICIANDO DEPLOY ==="
          log "Commit: ${{ github.sha }}"
          
          log "Verificando depend√™ncias..."
          python3 --version || error_exit "Python3 n√£o encontrado"
          docker --version || error_exit "Docker n√£o encontrado"
          docker-compose --version || error_exit "Docker Compose n√£o encontrado"
          
          cd /var/www/juscash || error_exit "Diret√≥rio /var/www/juscash n√£o encontrado"
          log "‚úì Etapa 1/18: Diret√≥rio atual: $(pwd)"
          
          if [ -f .env ]; then
              cp .env .env.backup_$(date +%Y%m%d_%H%M%S)
              log "‚úì Etapa 2/18: Backup do .env criado"
          else
              log "‚úì Etapa 2/18: Arquivo .env n√£o existe, pulando backup"
          fi
          
          git stash --include-untracked || true
          log "‚úì Etapa 3/18: Mudan√ßas locais salvas com stash"
          
          git fetch origin
          git reset --hard origin/master
          log "‚úì Etapa 4/18: C√≥digo atualizado do reposit√≥rio"
          
          docker-compose -f docker-compose.prod.yml stop web || true
          docker-compose -f docker-compose.prod.yml rm -f web || true
          log "‚úì Etapa 5/18: Container web parado"
          
          docker rmi juscash-api-web:latest 2>/dev/null || true
          docker rmi juscash_web:prod 2>/dev/null || true
          OLD_IMAGES=$(docker images -q --filter "reference=juscash-api-web" 2>/dev/null || true)
          if [ -n "$OLD_IMAGES" ]; then
              docker rmi $OLD_IMAGES 2>/dev/null || true
          fi
          log "‚úì Etapa 6/18: Imagem antiga do web removida"
          
          echo "${{ github.sha }}" > VERSION
          log "‚úì Etapa 7/18: Arquivo VERSION criado com hash: ${{ github.sha }}"
          
          log "‚úì Etapa 8/18: Configurando ambiente de produ√ß√£o"
          
          if [ -f .env ]; then
              log "Arquivo .env j√° existe - reutilizando vari√°veis existentes"
              # Extrair POSTGRES_PASSWORD e SECRET_KEY existentes
              export $(grep -E '^POSTGRES_PASSWORD=' .env | xargs) || true
              export $(grep -E '^SECRET_KEY=' .env | xargs) || true
              POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-$(python3 -c 'import secrets,random,string,sys; sys.stdout.write("".join(random.choices(string.ascii_letters+string.digits,k=32)))')}
              SECRET_KEY=${SECRET_KEY:-$(python3 -c 'import secrets,sys; sys.stdout.write(secrets.token_urlsafe(64))')}
              log "Senhas existentes reutilizadas: POSTGRES_PASSWORD=${POSTGRES_PASSWORD:0:8}..."
          else
              log "Gerando chaves seguras..."
              SECRET_KEY=$(python3 -c "import secrets; print(secrets.token_urlsafe(64))") || error_exit "Falha ao gerar SECRET_KEY"
              POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-$(python3 -c 'import secrets,random,string,sys; sys.stdout.write("".join(random.choices(string.ascii_letters+string.digits,k=32)))')}

              log "Criando arquivo .env pela primeira vez..."
              echo "PRODUCTION=true" > .env
              echo "FLASK_ENV=production" >> .env
              echo "SECRET_KEY=${SECRET_KEY}" >> .env
              echo "POSTGRES_DB=juscash_db" >> .env
              echo "POSTGRES_USER=juscash" >> .env
              echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}" >> .env
              echo "DATABASE_URL=postgresql://juscash:${POSTGRES_PASSWORD}@db:5432/juscash_db" >> .env
              echo "REDIS_URL=redis://redis:6379/0" >> .env
              echo "DJE_BASE_URL=https://dje.tjsp.jus.br/cdje" >> .env
              echo "SCRAPING_ENABLED=true" >> .env
              echo "DAILY_SCRAPING_SCHEDULE=3600" >> .env
              echo "WEEKLY_SCRAPING_SCHEDULE=604800" >> .env
              echo "CLEANUP_SCHEDULE=86400" >> .env
              echo "DB_POOL_SIZE=10" >> .env
              echo "DB_POOL_RECYCLE=300" >> .env
              echo "FLOWER_USER=admin" >> .env
              echo "FLOWER_PASSWORD=juscash2024" >> .env
              log "‚úì Arquivo .env criado com POSTGRES_PASSWORD=${POSTGRES_PASSWORD:0:8}..."
          fi
          
          log "Iniciando banco de dados e Redis..."
          docker-compose -f docker-compose.prod.yml up -d db redis || error_exit "Falha ao iniciar banco de dados e Redis"
          log "‚úì Etapa 9/18: Banco de dados e Redis iniciados"
          
          log "Aguardando banco de dados ficar pronto..."
          for i in {1..30}; do
              if docker-compose -f docker-compose.prod.yml exec -T db pg_isready -U juscash > /dev/null 2>&1; then
                  log "‚úì Etapa 10/18: Banco de dados est√° pronto"
                  break
              fi
              if [ $i -eq 30 ]; then
                  log "‚úó ERRO: Banco de dados n√£o ficou pronto ap√≥s 30 tentativas"
                  docker-compose -f docker-compose.prod.yml logs db | tail -20 >> "$LOG_FILE"
                  exit 1
              fi
              sleep 2
          done
          
          log "Configurando banco de dados..."
          docker-compose -f docker-compose.prod.yml exec -T db psql -U juscash -d postgres -c "CREATE DATABASE juscash_db;" 2>/dev/null || true
          log "‚úì Etapa 11/18: Banco de dados criado ou j√° existente"
          
          log "Construindo nova imagem web..."
          docker-compose -f docker-compose.prod.yml build --no-cache web || error_exit "Falha ao construir imagem web"
          log "‚úì Etapa 12/18: Nova imagem web constru√≠da"
          
          log "Iniciando container web..."
          docker-compose -f docker-compose.prod.yml up -d web || error_exit "Falha ao iniciar container web"
          log "‚úì Etapa 13/18: Container web iniciado"
          
          log "Aguardando aplica√ß√£o iniciar..."
          
          for i in {1..6}; do
              log "Verifica√ß√£o $i/6: Aguardando 10 segundos..."
              sleep 10
              
              log "Status atual dos containers:"
              docker-compose -f docker-compose.prod.yml ps
              
              if docker-compose -f docker-compose.prod.yml ps | grep -q "juscash_web_prod.*Up"; then
                  log "‚úì Container web ainda est√° rodando"
                  
                  log "Verificando se aplica√ß√£o responde:"
                  HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/api/simple/ping || echo "000")
                  log "Status HTTP da aplica√ß√£o: $HTTP_STATUS"
                  
                  if [ "$HTTP_STATUS" = "200" ]; then
                      log "üéâ Aplica√ß√£o est√° respondendo corretamente!"
                      break
                  else
                      log "‚ö†Ô∏è Aplica√ß√£o ainda n√£o est√° respondendo..."
                  fi
              else
                  log "‚ùå Container web n√£o est√° mais rodando!"
                  log "=== LOGS COMPLETOS DO CONTAINER WEB ==="
                  docker-compose -f docker-compose.prod.yml logs web
                  log "=== LOGS DO BANCO DE DADOS ==="
                  docker-compose -f docker-compose.prod.yml logs db | tail -20
                  log "=== LOGS DO REDIS ==="
                  docker-compose -f docker-compose.prod.yml logs redis | tail -20
                  error_exit "Container web crashou durante inicializa√ß√£o na verifica√ß√£o $i"
              fi
              
              log "Logs recentes do container web:"
              docker-compose -f docker-compose.prod.yml logs --tail=5 web
              
              if [ $i -eq 6 ]; then
                  log "‚ö†Ô∏è Aplica√ß√£o n√£o respondeu ap√≥s 60 segundos, mas container est√° rodando"
                  log "=== LOGS DETALHADOS PARA DEBUG ==="
                  docker-compose -f docker-compose.prod.yml logs web
              fi
          done
          
          log "Verifica√ß√£o final da aplica√ß√£o..."
          FINAL_HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/api/simple/ping || echo "000")
          
          if [ "$FINAL_HTTP_STATUS" = "200" ]; then
              log "‚úì Etapa 14/18: Aplica√ß√£o web est√° rodando e respondendo corretamente"
          else
              log "‚ö†Ô∏è Etapa 14/18: Container est√° rodando mas aplica√ß√£o n√£o responde (HTTP: $FINAL_HTTP_STATUS)"
              log "Continuando deploy - aplica√ß√£o pode estar inicializando..."
          fi
          
          log "Verificando cria√ß√£o de tabelas..."
          log "‚úì Etapa 15/18: Tabelas ser√£o criadas automaticamente pelo run.py"
          
          docker-compose -f docker-compose.prod.yml up -d worker
          log "‚úì Etapa 16/18: Worker Celery iniciado"
          
          docker-compose -f docker-compose.prod.yml up -d flower
          log "‚úì Etapa 17/18: Flower iniciado"
          
          log "Testando endpoint da API..."
          
          log "Aguardando 5 segundos antes do teste final..."
          sleep 5
          
          RESPONSE=$(curl -s http://localhost:5000/api/simple/ping 2>/dev/null || echo "ERRO_CONEXAO")
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/api/simple/ping 2>/dev/null || echo "000")
          
          log "Resposta da API: $RESPONSE"
          log "C√≥digo HTTP: $HTTP_CODE"
          
          if [ "$HTTP_CODE" = "200" ] && [ "$RESPONSE" != "ERRO_CONEXAO" ]; then
              log "‚úÖ Etapa 18/18: API respondendo corretamente!"
          else
              log "‚ö†Ô∏è Etapa 18/18: API n√£o est√° respondendo como esperado"
              log "Verificando logs finais do container web:"
              docker-compose -f docker-compose.prod.yml logs --tail=20 web
          fi
          
          log "=== DEPLOY CONCLU√çDO COM SUCESSO ==="
          log "Vers√£o deployada: ${{ github.sha }}"
          
          echo "=== LOGS DO CONTAINER WEB ==="
          docker-compose -f docker-compose.prod.yml logs --tail=20 web
          
          echo "=== STATUS DOS CONTAINERS ==="
          docker-compose -f docker-compose.prod.yml ps 